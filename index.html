<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Variable Wallet</title>
    <style>
        /* Base styles */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #111111;
        }

        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Title styles */
        .title-container {
            position: fixed;
            top: 40px;
            width: 100%;
            text-align: center;
            z-index: 1000;
            pointer-events: none;
        }

        .title {
            font-family: 'Inter', sans-serif;
            font-size: 32px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 12px;
            text-transform: uppercase;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        .fancy-letter {
            font-family: 'Pinyon Script', cursive;
            font-size: 48px;
            text-transform: none;
            letter-spacing: 0;
            display: inline-block;
            transform: translateY(5px);
        }

        .subtitle {
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 8px;
            text-transform: uppercase;
            margin-top: 10px;
        }

        /* Control panel styles */
        .control-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
        }

        /* Brightness slider */
        .brightness-control {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(17, 17, 17, 0.1);
            padding: 10px 16px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(1.5px);
        }

        .brightness-control span {
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            letter-spacing: 1.5px;
            user-select: none;
        }

        .brightness-control input[type="range"] {
            width: 120px;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
        }

        .brightness-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Material selector */
        .material-select {
            position: fixed;
            right: 40px;
            top: 40px;
            z-index: 1000;
        }

        select {
            background: rgba(17, 17, 17, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            border-radius: 8px;
            cursor: pointer;
            backdrop-filter: blur(1.5px);
            letter-spacing: 1px;
        }

        select:hover {
            border-color: rgba(255, 255, 255, 0.3);
        }

        option {
            background: rgba(17, 17, 17, 0.95);
            color: rgba(255, 255, 255, 0.9);
            padding: 8px;
        }

        /* Footer styles */
        .footer {
            position: fixed;
            bottom: 20px;
            width: 100%;
            text-align: center;
            z-index: 1000;
            pointer-events: none;
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 4px;
            text-transform: uppercase;
            opacity: 0.8;
        }

        /* Add to your existing styles */
        .material-select select {
            /* Existing styles... */
            direction: ltr;  /* Text aligns left */
        }
        
        /* Force dropdown to open downward */
        .material-select {
            transform-origin: top right;
            transform: translateY(0);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300&family=Pinyon+Script&display=swap" rel="stylesheet">
</head>
<body>
    <div class="title-container">
        <div class="title">
            <span class="fancy-letter">V</span>&#8202;ariable 
            <span class="fancy-letter">W</span>&#8202;allet
        </div>
        <div class="subtitle">Coming 2025</div>
    </div>

    <div class="material-select">
        <select id="finishSelect" style="direction: rtl;">
            <option value="aluminum" selected>Aluminum</option>
            <option value="titanium">Titanium</option>
            <option value="damascus">Damascus Steel</option>
        </select>
    </div>

    <div class="container" id="canvas-container"></div>

    <div class="control-panel">
        <div class="brightness-control">
            <span>Light</span>
            <input type="range" id="brightnessSlider" min="1" max="200" value="20">
        </div>
    </div>

    <div class="footer">Made With Love in the USA</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/OBJLoader.js"></script>

    <script>
        // Add to global variables at top
        let scene, camera, renderer, model;
        let isMouseDown = false;
        let startX, startY;
        let rotationX = 0;
        let rotationY = 0;
        let currentX, currentY;
        const rotationSpeed = 0.02;
        const frustumSize = 15;  // Move this to global scope
        let walletPieces = [];
        let isExploded = false;
        const SEPARATION_DISTANCE = 2;  // Distance in units
        let separationAnimation = null;
        let constitutionTexture, constitutionPlane;  // Add these
        let constitutionScale = 1.0;
        let constitutionScaleDirection = 1;
        const SCALE_SPEED = 0.0001;
        const MIN_SCALE = 0.98;
        const MAX_SCALE = 1.02;
        let walletBoxes = [];  // Store collision boxes
        const COLLISION_PADDING = 0.1;  // Small padding for collision boxes

        // Add to global variables
        const OPEN_POSITIONS = {
            left: new THREE.Vector3(0, 0, -SEPARATION_DISTANCE),
            center: new THREE.Vector3(0, 0, 0),
            right: new THREE.Vector3(0, 0, SEPARATION_DISTANCE)
        };

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Add to global variables
        let rotationZ = 0;
        let currentZ = 0;

        function init() {
            console.log("Starting initialization...");
            diagnosticCheck();  // Initial check
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            console.log("Scene created");

            // Add camera (using global frustumSize)
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2,
                frustumSize * aspect / 2,
                frustumSize / 2,
                frustumSize / -2,
                0.1,
                2000
            );
            camera.position.set(0, 0, 20);
            camera.lookAt(0, 0, 0);

            // Add single adjustable spotlight
            const spotLight = new THREE.SpotLight(0xffffff, 2.0);
            spotLight.position.set(0, 10, 10);
            spotLight.target.position.set(0, 0, 0);
            spotLight.angle = Math.PI / 3;
            spotLight.penumbra = 0.2;
            spotLight.decay = 1.5;
            spotLight.distance = 100;
            scene.add(spotLight);
            scene.add(spotLight.target);

            // Connect brightness slider with adjusted range
            const brightnessSlider = document.getElementById('brightnessSlider');
            brightnessSlider.value = 20;  // Set default to 20 (2.0 intensity)
            brightnessSlider.addEventListener('input', (e) => {
                const intensity = e.target.value / 10;  // Convert 0-200 to 0-20 range
                spotLight.intensity = intensity;
            });

            // Create renderer first
            try {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                console.log("Renderer created");
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.shadowMap.enabled = true;
                document.getElementById('canvas-container').appendChild(renderer.domElement);
            } catch (e) {
                console.error("Error creating renderer:", e);
            }

            // At the start of init()
            const initialRotationX = Math.PI;  // 180 degrees = Ï€ radians
            const initialRotationY = 0;
            const initialRotationZ = 0;

            // Load model
            const loader = new THREE.OBJLoader();
            loader.load(
                'VW.obj',
                function(object) {
                    model = object;
                    
                    // Find exact center of model
                    const box = new THREE.Box3().setFromObject(model);
                    const modelCenter = box.getCenter(new THREE.Vector3());
                    
                    // Create pivot point at exact center
                    const pivot = new THREE.Group();
                    scene.add(pivot);
                    
                    // Add model to pivot
                    pivot.add(model);
                    
                    // Scale the model
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = (5 * 1.33) / maxDim;
                    model.scale.set(scale, scale, scale);
                    
                    // Store pivot reference
                    model.pivot = pivot;
                    
                    // Initial rotation
                    pivot.rotation.x = Math.PI;
                    
                    // Update tracking variables
                    rotationX = Math.PI;
                    rotationY = 0;
                    currentX = Math.PI;
                    currentY = 0;

                    // Store pieces
                    walletPieces = [];
                    model.traverse(function(child) {
                        if (child instanceof THREE.Mesh) {
                            walletPieces.push(child);
                            child.originalPosition = child.position.clone();
                        }
                    });

                    // Update materials
                    updateFinish('aluminum');
                    
                    // Force a render
                    renderer.render(scene, camera);

                    // Run diagnostic after setup
                    setTimeout(diagnosticCheck, 100);
                },
                function(xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function(error) {
                    console.error("Error loading model:", error);
                }
            );

            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (model && model.pivot) {
                // Smooth pivot rotation
                model.pivot.rotation.x += (rotationX - model.pivot.rotation.x) * 0.1;
                model.pivot.rotation.y += (rotationY - model.pivot.rotation.y) * 0.1;
                
                // Keep all pieces synchronized
                walletPieces.forEach(piece => {
                    piece.rotation.copy(model.pivot.rotation);
                });
            }

            renderer.render(scene, camera);
        }

        function updateMaterial() {
            if (!model) return;
            
            const textureLoader = new THREE.TextureLoader();
            const damascusTexture = textureLoader.load('TXTR.jpg', function(texture) {
                const scale = 3;  // Reduced to 3K
                
                const canvas = document.createElement('canvas');
                canvas.width = texture.image.width * scale;
                canvas.height = texture.image.height * scale;
                const ctx = canvas.getContext('2d');
                
                // Enhanced smoothing
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(texture.image, 0, 0, canvas.width, canvas.height);
                
                // Larger kernel for more smoothing
                const kernel = [
                    [1, 2, 4, 8, 4, 2, 1],
                    [2, 4, 8, 16, 8, 4, 2],
                    [4, 8, 16, 32, 16, 8, 4],
                    [8, 16, 32, 64, 32, 16, 8],
                    [4, 8, 16, 32, 16, 8, 4],
                    [2, 4, 8, 16, 8, 4, 2],
                    [1, 2, 4, 8, 4, 2, 1]
                ];
                const kernelSum = 512;  // Sum of all kernel values
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const tempData = new Uint8ClampedArray(data);
                
                // Process the image data - adjust to gunmetal grey for dark areas
                for (let i = 0; i < data.length; i += 4) {
                    // Get average brightness
                    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    
                    // Compress the range and lift the dark values to gunmetal grey
                    const compressedAvg = (avg * 0.3) + 100; // Increased from 85 to 100 for lighter darks
                    
                    // Apply gunmetal tint to darker areas
                    const gunmetalR = compressedAvg * 0.95; // Slightly red-tinted
                    const gunmetalG = compressedAvg * 0.98; // More green for gunmetal
                    const gunmetalB = compressedAvg * 1.02; // Slight blue tint
                    
                    // Apply values with gunmetal tinting
                    data[i] = gunmetalR;     // Red component
                    data[i + 1] = gunmetalG;  // Green component
                    data[i + 2] = gunmetalB;  // Blue component
                }
                
                // Apply the larger smoothing kernel
                for (let y = 3; y < canvas.height - 3; y++) {
                    for (let x = 3; x < canvas.width - 3; x++) {
                        const idx = (y * canvas.width + x) * 4;
                        let r = 0, g = 0, b = 0;
                        
                        // Apply larger kernel
                        for (let ky = -3; ky <= 3; ky++) {
                            for (let kx = -3; kx <= 3; kx++) {
                                const offset = ((y + ky) * canvas.width + (x + kx)) * 4;
                                const weight = kernel[ky + 3][kx + 3];
                                r += data[offset] * weight;
                                g += data[offset + 1] * weight;
                                b += data[offset + 2] * weight;
                            }
                        }
                        
                        // Brighter thresholds and dark areas
                        const brightness = (r + g + b) / (3 * kernelSum);
                        if (brightness > 0.4) {  // Light areas stay the same
                            data[idx] = (r/kernelSum * 0.85);
                            data[idx + 1] = (g/kernelSum * 0.9);
                            data[idx + 2] = (b/kernelSum * 0.95);
                        } else {
                            // Dark areas are 10% brighter
                            data[idx] = (r/kernelSum) * 0.99;       // Increased from 0.9
                            data[idx + 1] = (g/kernelSum) * 0.99;   // Increased from 0.9
                            data[idx + 2] = (b/kernelSum) * 0.99;   // Increased from 0.9
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // Create enhanced shine map
                const shineCanvas = document.createElement('canvas');
                shineCanvas.width = canvas.width;
                shineCanvas.height = canvas.height;
                const shineCtx = shineCanvas.getContext('2d');
                
                // Adjust shine map thresholds
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const avg = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;
                    const normalized = (avg - 128) * 0.6 + 128; // More contrast reduction
                    
                    // Lower shine thresholds
                    const shineFactor = avg > 160 ? 200 : (avg > 130 ? avg * 0.7 : 0);
                    shineCtx.fillStyle = `rgb(${shineFactor},${shineFactor * 0.9},${shineFactor * 1.05})`;
                    shineCtx.fillRect((i/4) % canvas.width, Math.floor((i/4) / canvas.width), 1, 1);
                }
                
                // Create main texture
                texture.image = canvas;
                texture.needsUpdate = true;
                texture.anisotropy = 1;
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.NearestFilter;
                texture.generateMipmaps = false;
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
                
                // Create shine texture
                const shineTexture = new THREE.CanvasTexture(shineCanvas);
                shineTexture.anisotropy = 1;
                shineTexture.magFilter = THREE.NearestFilter;
                shineTexture.minFilter = THREE.NearestFilter;
                shineTexture.wrapS = THREE.RepeatWrapping;
                shineTexture.wrapT = THREE.RepeatWrapping;
                shineTexture.repeat.set(1, 1);
                
                model.traverse(function(child) {
                    if (child instanceof THREE.Mesh) {
                        const geometry = child.geometry;
                        const positions = geometry.attributes.position;
                        const uvs = new Float32Array(positions.count * 2);
                        
                        for (let i = 0; i < positions.count; i++) {
                            const x = positions.getX(i);
                            const y = positions.getY(i);
                            const z = positions.getZ(i);
                            
                            const ax = Math.abs(x);
                            const ay = Math.abs(y);
                            const az = Math.abs(z);
                            
                            // Adjust UV scale based on face size
                            const faceSize = Math.max(ax, ay, az);
                            const uvScale = faceSize > 4 ? 0.5 : 1.0;  // Scale UV for larger faces
                            
                            if (ax > ay && ax > az) {
                                uvs[i * 2] = ((z / ax + 1) * 0.5) * uvScale;
                                uvs[i * 2 + 1] = ((y / ax + 1) * 0.5) * uvScale;
                            } else if (ay > ax && ay > az) {
                                uvs[i * 2] = ((x / ay + 1) * 0.5) * uvScale;
                                uvs[i * 2 + 1] = ((z / ay + 1) * 0.5) * uvScale;
                            } else {
                                uvs[i * 2] = ((x / az + 1) * 0.5) * uvScale;
                                uvs[i * 2 + 1] = ((y / az + 1) * 0.5) * uvScale;
                            }
                        }
                        
                        geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                        geometry.attributes.uv.needsUpdate = true;
                        
                        // Adjust material properties for matte finish with subtle pattern
                        child.material = new THREE.MeshPhysicalMaterial({
                            map: texture,
                            normalMap: texture,
                            roughnessMap: shineTexture,
                            aoMap: texture,
                            metalness: 0.85,             // More metallic
                            roughness: 0.35,             // Smoother surface
                            clearcoat: 0.6,              // Stronger clearcoat
                            clearcoatRoughness: 0.2,     // Smoother clearcoat
                            envMapIntensity: 1.2,        // Stronger reflections
                            normalScale: new THREE.Vector2(0.25, 0.25),
                            appearance: 'physical'  // Add standard appearance property
                        });
                    }
                });
            });
        }

        function calculateFaceArea(v1, v2, v3) {
            // Calculate area of triangle using cross product
            const ax = v2.x - v1.x;
            const ay = v2.y - v1.y;
            const az = v2.z - v1.z;
            const bx = v3.x - v1.x;
            const by = v3.y - v1.y;
            const bz = v3.z - v1.z;
            
            const cx = ay * bz - az * by;
            const cy = az * bx - ax * bz;
            const cz = ax * by - ay * bx;
            
            return Math.sqrt(cx * cx + cy * cy + cz * cz) / 2;
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Update mousemove handler for rotation
        document.addEventListener('mousemove', (e) => {
            if (!isMouseDown || !model) return;

            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;

            // Convert mouse movement to rotation
            // Left/right = Y axis rotation (twist)
            rotationY = currentY + (deltaX * Math.PI / 180);
            // Up/down = X axis rotation (tilt)
            rotationX = currentX + (deltaY * Math.PI / 180);

            if (model.pivot) {
                // Apply rotations in Y-X order for more natural movement
                model.pivot.rotation.order = 'YXZ';  // Change rotation order
                model.pivot.rotation.set(rotationX, rotationY, 0);
                
                // Keep pieces synchronized
                walletPieces.forEach(piece => {
                    piece.rotation.copy(model.pivot.rotation);
                });
            }

            renderer.render(scene, camera);
        });

        // Update mousedown handler to track Z
        document.addEventListener('mousedown', (e) => {
            if (!model || !walletPieces.length) return;

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(walletPieces);

            if (intersects.length > 0) {
                isMouseDown = true;
                startX = e.clientX;
                startY = e.clientY;
                currentX = model.pivot.rotation.x;
                currentY = model.pivot.rotation.y;
                currentZ = model.pivot.rotation.z;
            }
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        document.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });

        // Add event listener for material changes
        document.getElementById('finishSelect').addEventListener('change', function(e) {
            updateFinish(e.target.value);
        });

        function updateFinish(finish) {
            if (!model) return;
            
            model.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                    switch(finish) {
                        case 'aluminum':
                            // Brushed aluminum look
                            child.material = new THREE.MeshPhysicalMaterial({
                                color: 0xE8E8E8,        // Bright aluminum color
                                metalness: 0.95,        // Very metallic
                                roughness: 0.5,         // Semi-rough for brushed look
                                clearcoat: 0.8,         // Strong clearcoat
                                clearcoatRoughness: 0.2, // Smooth clearcoat
                                envMapIntensity: 1.5,   // Strong reflections
                                reflectivity: 0.9,      // High reflectivity
                                anisotropy: 0.5,        // Directional reflectance for brushed look
                                anisotropyRotation: Math.PI / 2 // Brush direction
                            });
                            break;
                            
                        case 'titanium':
                            // Ultra-dark, mirror-like titanium
                            child.material = new THREE.MeshPhysicalMaterial({
                                color: 0x2A2D30,        // Much darker titanium color
                                metalness: 1.0,         // Maximum metallic
                                roughness: 0.1,         // Very smooth for maximum shine
                                clearcoat: 1.0,         // Maximum clearcoat
                                clearcoatRoughness: 0.05, // Ultra-smooth clearcoat
                                envMapIntensity: 2.0,   // Much stronger reflections
                                reflectivity: 1.0,      // Maximum reflectivity
                                appearance: 'physical'   // Standard appearance
                            });
                            break;
                            
                        case 'damascus':
                            // Use existing damascus texture logic
                            updateDamascusTexture(child);
                            break;
                    }
                }
            });
        }

        // Move existing damascus texture logic to separate function
        function updateDamascusTexture(mesh) {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load('TXTR.jpg', function(texture) {
                const scale = 0.25;  // Keep the larger pattern size
                
                const canvas = document.createElement('canvas');
                canvas.width = texture.image.width * scale;
                canvas.height = texture.image.height * scale;
                const ctx = canvas.getContext('2d');
                
                // Use better image smoothing
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(texture.image, 0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Improved contrast and smoothing
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        const idx = (y * canvas.width + x) * 4;
                        
                        // Get surrounding pixels for smoothing
                        const neighbors = [];
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = Math.min(Math.max(x + dx, 0), canvas.width - 1);
                                const ny = Math.min(Math.max(y + dy, 0), canvas.height - 1);
                                const nidx = (ny * canvas.width + nx) * 4;
                                neighbors.push((data[nidx] + data[nidx + 1] + data[nidx + 2]) / 3);
                            }
                        }
                        
                        // Calculate median for smoother transitions
                        neighbors.sort((a, b) => a - b);
                        const medianValue = neighbors[4];
                        
                        // Apply contrast while maintaining smooth transitions
                        const contrast = 1.8;  // Slightly reduced contrast
                        const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                        const newValue = factor * (medianValue - 128) + 128;
                        
                        // Apply smoothed value
                        data[idx] = newValue;
                        data[idx + 1] = newValue;
                        data[idx + 2] = newValue;
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // Create improved shine texture
                const shineTexture = new THREE.CanvasTexture(canvas);
                shineTexture.minFilter = THREE.LinearFilter;
                shineTexture.magFilter = THREE.LinearFilter;
                
                // Update material with improved settings
                mesh.material = new THREE.MeshPhysicalMaterial({
                    map: texture,
                    normalMap: texture,
                    roughnessMap: shineTexture,
                    aoMap: texture,
                    metalness: 0.85,
                    roughness: 0.35,
                    clearcoat: 0.6,
                    clearcoatRoughness: 0.2,
                    envMapIntensity: 1.2,
                    normalScale: new THREE.Vector2(1.5, 1.5),  // Adjusted normal mapping
                    appearance: 'physical'
                });

                // Improve texture settings
                texture.minFilter = THREE.LinearMipmapLinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.repeat.set(0.25, 0.25);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.needsUpdate = true;
                
                // Force material update
                mesh.material.needsUpdate = true;
            });
        }

        // Add diagnostic system
        function diagnosticCheck() {
            console.log('=== Diagnostic Check ===');
            
            // Check scene
            if (!scene) {
                console.error('Scene not initialized!');
            } else {
                console.log('âœ“ Scene created');
                console.log('Scene children:', scene.children.length);
            }

            // Check renderer
            if (!renderer) {
                console.error('Renderer not initialized!');
            } else {
                console.log('âœ“ Renderer created');
            }

            // Check camera
            if (!camera) {
                console.error('Camera not initialized!');
            } else {
                console.log('âœ“ Camera created');
                console.log('Camera position:', camera.position);
            }

            // Check model and pivot
            if (!model) {
                console.error('Model not loaded!');
            } else {
                console.log('âœ“ Model loaded');
                if (model.pivot) {
                    console.log('âœ“ Pivot system active');
                    console.log('Pivot rotation:', model.pivot.rotation);
                } else {
                    console.error('Model pivot not created!');
                }
            }

            // Check wallet pieces
            console.log('Wallet pieces:', walletPieces.length);

            console.log('=== End Diagnostic ===');
        }

        // Call init after ensuring DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM loaded, initializing...");
            init();
        });

        // Add touch event handlers
        document.addEventListener('touchstart', (e) => {
            if (!model || !walletPieces.length) return;
            e.preventDefault(); // Prevent scrolling

            const touch = e.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(walletPieces);

            if (intersects.length > 0) {
                isMouseDown = true;
                startX = touch.clientX;
                startY = touch.clientY;
                currentX = model.pivot.rotation.x;
                currentY = model.pivot.rotation.y;
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (!isMouseDown || !model) return;
            e.preventDefault(); // Prevent scrolling

            const touch = e.touches[0];
            const deltaX = touch.clientX - startX;
            const deltaY = touch.clientY - startY;

            // Convert touch movement to rotation
            rotationY = currentY + (deltaX * Math.PI / 180);
            rotationX = currentX + (deltaY * Math.PI / 180);

            if (model.pivot) {
                model.pivot.rotation.order = 'YXZ';
                model.pivot.rotation.set(rotationX, rotationY, 0);
                
                walletPieces.forEach(piece => {
                    piece.rotation.copy(model.pivot.rotation);
                });
            }

            renderer.render(scene, camera);
        });

        document.addEventListener('touchend', () => {
            isMouseDown = false;
        });

        document.addEventListener('touchcancel', () => {
            isMouseDown = false;
        });
    </script>
</body>
</html> 